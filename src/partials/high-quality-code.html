<section class="slide chapter-wrapper">
    <div class="chapter-title">Проектирование при конструировании</div>
</section>
<section class="slide">
    <h2>Проектирование</h2>
    <p>Проектирование - разработка схемы преобразования спецификации в готовое приложение.</p>
    <div class="columns two">
        <ul>
            <li>Проектирование - "грязная проблема"</li>
            <li>Проектирование - неряшливый процесс</li>
            <li>Проектирование - определение компромиссов и приоритетов</li>
            <li>Проектирование - ограничение возможностей</li>
        </ul>
        <ul>
            <li>Проектирование - недетерминированный процесс</li>
            <li>Проектирование - эвристический процесс</li>
            <li>Проектирование - постепенные процесс</li>
        </ul>
    </div>
</section>
<section class="slide">
    <h2>
        Методики проектирования
    </h2>
    <ul>
        <li>Нисходящее (top-down) проектирование</li>
        <li>Восходящее (bottom-up) проектирование</li>
        <li>Экспериментальное прототипирование</li>
        <li>Совместное проектирование</li>
    </ul>
</section>
<section class="slide chapter-wrapper">
    <div class="chapter-title">Управление сложностью</div>
</section>
<section class="slide">
    <h2>Главный технический императив ПО</h2>
    <div>
        Не следует пытаться охватить всю программу сразу. Вместо этого мы должны попытаться организовывать программы
        так, что бы можно было безопасно работать с их отдельными фрагментами по очереди.
        <p>Дийкстра, 1972</p>
    </div>
    <div class="columns two">
        <div>
            Причины усложнения:
            <ul>
                <li>Сложное решение простой проблемы</li>
                <li>Простое, но неверное решение сложной проблемы</li>
                <li>Неадекватное сложное решение сложной проблемы</li>
            </ul>
        </div>
        <div>
            Подходы к управлению сложностью:
            <ul>
                <li>Старайтесь свести к минимуму объем существенной сложности, с которым придется работать в каждый
                    конкретный момент времени
                </li>
                <li>Сдерживайте необязательный рост несущественный сложности</li>
            </ul>
        </div>
    </div>
</section>
<section class="slide">
    <h2>Желательные характеристики проекта</h2>
    <div class="columns two">
        <ul>
            <li>Минимальная сложность</li>
            <li>Простота сопровождения</li>
            <li>Слабое сопряжение</li>
            <li>Расширяемость</li>
            <li>Возможность повторного использования</li>
            <li>Портируемость</li>
            <li>Высокий коэффициент объединения по входу</li>
        </ul>
        <ul>
            <li>Низкий или средний коэффициент разветвления по выходу</li>
            <li>Минимальная, но полная функциональность</li>
            <li>Стратификация</li>
            <li>Соответствие практикам, соглашениями и методикам</li>
        </ul>
    </div>
</section>
<section class="slide chapter-wrapper">
    <div class="chapter-title">Сопряжение</div>
</section>

<section class="slide">
    <h2>Критерии оценки сопряжения: Объем</h2>
    <div>Пример</div>
</section>
<section class="slide">
    <h2>Критерии оценки сопряжения: Видимость</h2>
    <div>Пример</div>
</section>
<section class="slide">
    <h2>Критерии оценки сопряжения: Гибкость</h2>
    <div>Пример</div>
</section>

<section class="slide">
    <h2>Простое сопряжение посредством аргументов</h2>
</section>
<section class="slide">
    <h2>Простое сопряжение посредством объекта</h2>
</section>
<section class="slide">
    <h2>Сопряжение посредством объекта параметра</h2>
</section>
<section class="slide">
    <h2>Семантическое сопряжение</h2>
</section>
<section class="slide chapter-wrapper">
    <div class="chapter-title">Классы</div>
</section>
<section class="slide">
    <h2>
        АТД
    </h2>
    <div>Абстрактный тип данных - это набор, включающий данные и выполняемые над ними операции.</div>
    <div>Преимущества использования АТД
    </div>
    <ul>
        <li>Возможность сокрытия деталей реализации</li>
        <li>Ограничение области изменений</li>
        <li>Более высокая информативность интерфейса</li>
        <li>Легкость оптимизации кода</li>
        <li>Легкость проверки кода</li>
        <li>Удобочитаемость и понятность кода</li>
        <li>Ограничение области использования данных</li>
        <li>Возможность работы с сущностями реального мира, а не с низкоуровневыми деталями реализации</li>
    </ul>
</section>
<section class="slide">
    <h2>Хорошая абстракция</h2>
    <ul>
        <li>Выражайте в интерфейсе класса согласованный уровень абстракции</li>
        <li>Убедитесь что понимаете, реализацией какой абстракции является класс</li>
        <li>Предоставляйте методы вместе с противоположными им методами</li>
        <li>Убирайте постороннюю информацию в другие классы</li>
        <li>Делайте интерфейсы программными, а не семантическими</li>
        <li>Опасайтесь нарушения целостности интерфейса при изменении класса</li>
        <li>Не добавляйте публичные свойства которые не согласуются с абстракцией интерфейса</li>
        <li>Рассматривайте абстракцию и связность вместе</li>
    </ul>
</section>
<section class="slide">
    <h2>Хорошая инкапсуляция</h2>
    <ul>
        <li>Минимизируйте публичные методы и свойства</li>
        <li>Не делайте предположений о клиентах класса</li>
        <li>Цените легкость чтения кода выше, чем удобство написания</li>
        <li>Очень, очень настороженно относитесь к семантическим нарушениям инкапсуляции</li>
        <li>Остерегайтесь слишком высокого сопряжения (high coupling)</li>
    </ul>
</section>
<section class="slide">
    <h2>Разумные причины создания классов</h2>
    <div class="columns two">
        <ul>
            <li>Моделирование объектов реального мира</li>
            <li>Моделирование абстрактных объектов</li>
            <li>Снижение сложности</li>
            <li>Изоляция сложности</li>
            <li>Сокрытие деталей реализации</li>
            <li>Ограничение влияния изменений</li>

        </ul>
        <ul>
            <li>Упрощение передачи параметров в методы</li>
            <li>Создание центральных точек управления</li>
            <li>Облегчение повторного использования кода</li>
            <li>Планирование создания семейств</li>
            <li>Упаковка родственных операций / команд</li>
            <li>Выполнение специфического вида рефакторинга</li>
        </ul>
    </div>

</section>
<section class="slide chapter-wrapper">
    <div class="chapter-title">Высококачественные методы</div>
</section>
<section class="slide">
    <h2>Разумные причины создания методов</h2>
    <div class="columns two">
        <ul>
            <li>Снижение сложности</li>
            <li>Формирование понятной промежуточной абстракции</li>
            <li>Предотвращение дублирования кода</li>
            <li>Поддержка наследования</li>
            <li>Сокрытие очередности действий</li>
            <li>Упрощение сложных булевых проверок</li>
            <li>Повышение быстродействия</li>

        </ul>
        <ul>
            <li>Изоляция сложности</li>
            <li>Сокрытие деталей реализации</li>
            <li>Ограничение влияния изменений</li>
            <li>Сокрытие глобальных данных</li>
            <li>Создание центральных точек управления</li>
            <li>Облегчение повторного использования кода</li>
            <li>Выполнение специфического рефакторинга</li>
        </ul>
    </div>

</section>
<section class="slide">
    <h2>Удачные имена методов
    </h2>
    <ul>
        <li>Название должно описывать то что выполняет метод</li>
        <li>Не использовать неоднозначные, расплывчатые, не выразительные глаголы в названии</li>
        <li>Не использовать номера в названии методов для дифференциации / разделению на шаги</li>
        <li>Не ограничивать длину метода искусственно</li>
        <li>Для названия метода можно использовать описание возвращаемого значения</li>
        <li>Метод можно именовать по схеме глагол + имя данных с которыми работает метод</li>
        <li>Дисциплинированно использовать антонимы</li>
        <li>Использовать конвенции именования</li>
    </ul>
</section>
<section class="slide">
    <h2>Советы по использованию аргументов
    </h2>
    <ul>
        <li>Если несколько методов используют одинаковые аргументы, то необходимо передавать их в одинаковом /
            согласованном порядке
        </li>
        <li>Не передавать не используемые аргументы</li>
        <li>Переменные статуса или ошибки передавать последними, так как они второстепенны по отношению к главной цели
            метода
        </li>
        <li>Не изменять входные параметры и не переприсваивать</li>
        <li>Ограничивать число аргументов не более 7, иначе следует передавать их как объект</li>
    </ul>
</section>
<section class="slide chapter-wrapper">
    <div class="chapter-title">Защитное программирование</div>
</section>
<section class="slide">
    <h2>Утверждения (assertion)
    </h2>
    <div>Утверждение - код, который проверяет правильность выполнения программы.<br/>
         Утверждения не предназначены для показа ошибок в продакшн режиме, они для дев режима и разработки.
    </div>
    <div>Общие принципы использования утверждений
    </div>
    <ul>
        <li>Используйте процедуры обработки ошибок для ожидаемых событий и утверждения для событий, которые происходить
            не должны
        </li>
        <li>Старайтесь не помещать выполняемый код в утверждения</li>
        <li>Используйте утверждения для документирования пред- и постусловий</li>
        <li>Для большей устойчивости проверяйте утверждения, а затем все равно обрабатывайте ошибки</li>
    </ul>
</section>
<section class="slide">
    <h2>Способы обработки ошибок
    </h2>
    <div>
        Выбор того или иного способа обработки ошибок зависит от того что важнее, Корректность или Устойчивость
    </div>
    <div class="columns two">
        <ul>
            <li>Вернуть нейтральное значение</li>
            <li>Заменить следующий корректным блоком данных</li>
            <li>Вернуть последний успешный результат</li>
            <li>Подставить ближайшее допустимое значение</li>
            <li>Записать лог ошибки</li>

        </ul>
        <ul>
            <li>Вернуть код ошибки</li>
            <li>Вызвать обработчик ошибок</li>
            <li>Показать сообщение об ошибке</li>
            <li>Обработать ошибку в месте возникновения</li>
            <li>Прекратить выполнение программы</li>
        </ul>
    </div>

</section>
<section class="slide">
    <h2>Исключения</h2>
    <ul>
        <li>Используйте исключения для оповещения других частей программы об ошибках</li>
        <li>Генерируйте исключения для действительно исключительных ситуаций и не используйте исключения по мелочам</li>
        <li>Избегайте выкидывание исключение в конструкторах</li>
        <li>Исключение должно содержать все необходимую информацию о причинах исключения</li>
        <li>Избегать пустых блоков catch</li>
        <li>Стандартизируйте работу с исключениями на проекте</li>
    </ul>
</section>
<section class="slide">
    <h2>Изоляция повреждений / баррикада
    </h2>
    <div>Публичные методы предполагают что получаемые данные небезопасны и отвечают за их проверку и исправление. Здесь
         используются обработчики ошибок.
    </div>
    <div>Приватные методы предполагают что полученные данные прошли проверку в публичном методе и безопасны. Здесь
         используются утверждения
    </div>
</section>

